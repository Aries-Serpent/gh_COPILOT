#!/usr/bin/env python3
"""Command-line wrapper to safely display long output lines.

Lines longer than ``DEFAULT_MAX_LINE_LENGTH`` bytes are wrapped to keep the
terminal from exceeding the 1600 byte limit documented in ``AGENTS.md``. When a
line is wrapped the visible marker ``DEFAULT_WRAP_MARK`` followed by a newline
is appended. The behaviour mirrors the preinstalled ``/usr/local/bin/clw``
utility referenced throughout the repository.
"""

from __future__ import annotations

import binascii
import os
import re
import sys

DEFAULT_MAX_LINE_LENGTH = 1550
DEFAULT_WRAP_MARK = "‚èé"


def split_into_chunks(data: bytes, chunk_size: int):
    """Yield chunks of ``data`` respecting word boundaries when possible."""

    word_wrap_re = re.compile(rb"^.*(\b).+", re.DOTALL)

    start = 0
    while True:
        end = start + chunk_size
        chunk = data[start:end]
        if len(chunk) < chunk_size:
            yield False, chunk
            return

        match = word_wrap_re.match(chunk)
        if match and match.start(1):
            chunk = chunk[: match.start(1)]

        yield True, chunk
        start += len(chunk)


def main() -> None:
    """Entry point for the ``clw`` command."""

    env_max = os.environ.get("CLW_MAX_LINE_LENGTH")
    max_len = int(env_max) if env_max else DEFAULT_MAX_LINE_LENGTH

    env_mark = os.environ.get("CLW_WRAP_MARK")
    wrap_mark = (
        binascii.unhexlify(env_mark) if env_mark else DEFAULT_WRAP_MARK.encode("utf-8")
    ) + b"\n"

    chunk_size = max_len - len(wrap_mark)
    if chunk_size <= 0:
        raise ValueError("CLW_MAX_LINE_LENGTH too small")

    for line in sys.stdin.buffer:
        for wrapped, chunk in split_into_chunks(line, chunk_size):
            sys.stdout.buffer.write(chunk)
            if wrapped:
                sys.stdout.buffer.write(wrap_mark)
            sys.stdout.buffer.flush()


if __name__ == "__main__":
    main()

